#!/usr/bin/env python3

# A Prototype for Generating a Python Mapping from an ITL File

import sys
import json
from enum import Enum, auto
from argparse import ArgumentParser
from pathlib import Path
from os.path import relpath

class Name:

  def __init__(self, itl_name=None, parts=None):
    if itl_name is not None and parts is None:
      self.itl_name = itl_name
      self.parts = itl_name.split(':')[1].split('/')
    elif itl_name is None and parts is not None:
      self.itl_name = None
      self.parts = parts
    else:
      raise ValueError('Either parts or itl_name must be passed')

  def relative_to(self, target):
    parts = Path(relpath('/'.join(target), '/'.join(current))).parts
    up = parts.count('..')
    return ('.' * (up + 1)) + '.'.join(parts[up:])

class Type:

  def __init__(self, note):
    self.note = note
    self.name = None

  def set_name(self, itl_name):
    self.name = Name(itl_name)

  def accept(self, visitor):
    raise NotImplementedError

class PrimitiveType(Type):

  class Kind(Enum):
    u8 = auto()
    i8 = auto()
    u16 = auto()
    i16 = auto()
    u32 = auto()
    i32 = auto()
    u64 = auto()
    i64 = auto()
    f32 = auto()
    f64 = auto()
    c8 = auto()
    s8 = auto()

  def __init__(self, kind, note):
    super().__init__(note)
    if kind not in self.Kind:
      raise ValueError('Invalid Primitive Kind: ' + repr(kind))
    self.kind = kind

class StructType(Type):

  def __init__(self, note):
    super().__init__(note)
    self.fields = {}

  def add_field(self, name, type_node, optional):
    self.fields[name] = (type_node, optional)

  def accept(self, visitor):
    visitor.visit_struct(self)

class EnumType(Type):

  def __init__(self, note):
    super().__init__(note)
    self.members = {}
    self.default_member = None

  def add_member(self, name, value):
    self.members[name] = value
    if self.default_member is None:
      self.default_member = name

  def accept(self, visitor):
    visitor.visit_enum(self)

class TypeVisitor:

  def visit_struct(self, struct_type):
    raise NotImplementedError

  def visit_enum(self, enum_type):
    raise NotImplementedError

class Output(TypeVisitor):

  def __init__(self, path : Path):
    self.path = path
    self.contents = []

  def write(self):
    self.path.write_text('\n'.join(self.contents))

  def extend(self, lines, insert_newline=True):
    if self.contents and insert_newline:
      self.contents.append('')
    self.contents.extend(lines)

class PythonOutput(Output):

  primitive_types = { # (Python Type, Default Default Value)
    PrimitiveType.Kind.u8: ('int', '0'),
    PrimitiveType.Kind.i8: ('int', '0'),
    PrimitiveType.Kind.u16: ('int', '0'),
    PrimitiveType.Kind.i16: ('int', '0'),
    PrimitiveType.Kind.u32: ('int', '0'),
    PrimitiveType.Kind.i32: ('int', '0'),
    PrimitiveType.Kind.u64: ('int', '0'),
    PrimitiveType.Kind.i64: ('int', '0'),
    PrimitiveType.Kind.f32: ('float', '0.0'),
    PrimitiveType.Kind.f64: ('float', '0.0'),
    PrimitiveType.Kind.c8: ('str', "'\\x00'"),
    PrimitiveType.Kind.s8: ('str', "''"),
  }

  def __init__(self, root_package_name, path):
    super().__init__(path)
    self.root_package_name = root_package_name
    self.imports = set()

  def stdlib_import_name(self, name):
    return '_pystdlib_' + name

  def add_stdlib_import(self, name):
    iname = self.stdlib_import_name(name)
    if iname not in self.imports:
      self.imports |= {iname}
      self.contents.insert(0, 'import {} as {}'.format(name, iname))
    return iname

  def add_import(self, current_scope, scoped_name):
    full_name = '.'.join(scoped_name)
    item = scoped_name[-1]
    if full_name not in self.imports:
      import_module = relative_module(
        [self.root_package_name] + current_scope,
        [self.root_package_name] + scoped_name[:-1])
      self.imports |= {full_name}
      self.contents.insert(0, 'from {} import {}'.format(import_module, item))
    return item

  def scoper(self, current_scope, node):
    if current_scope == node.scoped_name[:-1]:
      return node.scoped_name[-1]
    else:
      return self.add_import(current_scope, node.scoped_name)

  def get_python_name(self, current_scope, node):
    node_type = type(node)
    if node_type is PrimitiveType:
      name = self.primitive_types[node.kind][0]
    elif node_type is StructType:
      name = self.scoper(current_scope, node)
    elif node_type is EnumType:
      name = self.scoper(current_scope, node)
    else:
      raise TypeError("Can't get Python Name for a " + repr(node_type))
    return name

  def get_python_default_value(self, current_scope, node):
    node_type = type(node)
    if node_type is PrimitiveType:
      return self.primitive_types[node.kind][1]
    elif node_type is StructType:
      return self.scoper(current_scope, node) + '()'
    elif node_type is EnumType:
      return '{}.{}'.format(self.scoper(current_scope, node), node.default_member)
    else:
      raise TypeError("Can't get Python Default Value for a " + repr(node_type))

  def visit_struct(self, struct_type):
    pydataclass_name = self.add_stdlib_import('dataclasses') + '.dataclass'
    result = [
      '@' + pydataclass_name,
      'class ' + struct_type.name + ':']
    current_scope = struct_type.scoped_name[:-1]
    for field_name, field_properities in struct_type.fields.items():
      field_type = field_properities[0]
      result.append('    {}: {} = {}'.format(
        field_name,
        self.get_python_name(current_scope, field_type),
        self.get_python_default_value(current_scope, field_type)))
    self.extend(result)

  def visit_enum(self, enum_type):
    pyenum_name = self.add_stdlib_import('enum') + '.IntFlag'
    result = ['class {}({}):'.format(enum_type.name, pyenum_name)]
    for name, value in enum_type.members.items():
      result.append('    {} = {}'.format(name, value))
    self.extend(result)

def parse_int(details):
  note = details.get('note', {})
  unsigned = 'unsigned' in details and details['unsigned'] == True
  enum = 'values' in details and 'constrained' in details and details['constrained']
  char = False
  try:
    char = details['note']['presentation']['type'] == 'char'
  except KeyError:
    pass

  kind = None
  if 'bits' in details:
    bits = details['bits']
    if bits == 8:
      if unsigned:
        kind = PrimitiveType.Kind.u8
      else:
        kind = PrimitiveType.Kind.i8
    elif bits == 16:
      if unsigned:
        kind = PrimitiveType.Kind.u16
      else:
        kind = PrimitiveType.Kind.i16
    elif bits == 32:
      if unsigned:
        kind = PrimitiveType.Kind.u32
      else:
        kind = PrimitiveType.Kind.i32
    elif bits == 64:
      if unsigned:
        kind = PrimitiveType.Kind.u64
      else:
        kind = PrimitiveType.Kind.i64

  if char and kind == PrimitiveType.Kind.u8:
    kind = PrimitiveType.Kind.c8
  elif enum:
    enum_type = EnumType(note)
    for k, v in details['values'].items():
      enum_type.add_member(k, v)
    return enum_type

  if kind:
    return PrimitiveType(kind, note)
  else:
    raise ValueError('Can\'t decide what this int type is: ' + repr(details))

def parse_float(details):
  raise NotImplementedError

def parse_fixed(details):
  raise NotImplementedError

def parse_string(details):
  raise NotImplementedError

def parse_sequence(types, details):
  raise NotImplementedError

def parse_record(types, details):
  struct_type = StructType(details.get('note', {}))
  for field_dict in details['fields']:
    struct_type.add_field(
      field_dict['name'], parse_type(types, field_dict['type']),
      field_dict.get('optional', False))
  return struct_type

def parse_union(types, details):
  raise NotImplementedError

def parse_alias(types, details):
  the_type = parse_type(types, details['type'])
  the_type.set_name(details['name'])
  return the_type

def parse_typedef(types, details):
  kind = details['kind']
  if kind == 'int':
    return parse_int(details)
  elif kind == 'float':
    return parse_float(details)
  elif kind == 'fixed':
    return parse_fixed(details)
  elif kind == 'string':
    return parse_string(details)
  elif kind == 'sequence':
    return parse_sequence(types, details)
  elif kind == 'record':
    return parse_record(types, details)
  elif kind == 'union':
    return parse_union(types, details)
  elif kind == 'alias':
    return parse_alias(types, details)
  else:
    raise ValueError(
      'Kind "{}" is not a valid type for parse_typedef()'.format(kind))

def parse_type(types, details):
  details_type = type(details)
  if details_type is str:
    if details in types:
      return types[details]
    else:
      raise ValueError("Invalid Type: " + details)
  elif details_type is dict:
    return parse_typedef(types, details)
  else:
    raise TypeError(
      'Type {} is not a valid type for parse_type()'.format(details_type.__name__))

def parse_root(types, itl):
  for itl_type in itl['types']:
    parsed_type = parse_type(types, itl_type)
    if not parsed_type.itl_name:
      raise ValueError('Invalid type name ' + repr(parsed_type.itl_name))
    # opendds_idl produces ITL that includes types from included IDL files, so
    # just use the first definition we found.
    if parsed_type.itl_name not in types:
      types[parsed_type.itl_name] = parsed_type

def create_package(root_package_name, output, name, contents):
  submodules = contents[0]
  type_nodes = contents[1]
  idl_module = '_PyOpenDDS'

  # Create Directory
  path = output / name
  path.mkdir(exist_ok=True)

  # Create __init__.py file
  with (path / '__init__.py').open('w') as f:
    print('from .{} import *'.format(idl_module), file=f)

  # Create IDL Module
  pyout = PythonOutput(root_package_name, path / (idl_module + '.py'))
  for type_node in type_nodes.values():
    type_node.accept(pyout)
  pyout.write()

  # Recurse
  for submodule in submodules.items():
    create_package(root_package_name, path, *submodule)

if __name__ == "__main__":
  # Parse Arguments
  argparser = ArgumentParser(description='ITL to Python Mapping')
  argparser.add_argument('itl_files', metavar='ITL_FILE', type=Path, nargs='+')
  argparser.add_argument('-n', '--package-name', type=str)
  argparser.add_argument('-o', '--output', type=Path, default=Path('.'))
  args = argparser.parse_args()

  if args.package_name is None:
    if len(args.itl_files) > 1:
      sys.exit('--package-name is required when using multiple ITL files')
    args.package_name = args.itl_files[0].stem

  # Parse ITL Files for Types
  types = {}
  for itl_file in args.itl_files:
    with itl_file.open() as f:
      parse_root(types, json.load(f))

  # Sort Types into Modules
  modules = ({}, {}) # (Submodules, Types)
  for type_node in types.values():
    module = modules
    for module_name in type_node.scoped_name[:-1]:
      module[0].setdefault(module_name, ({}, {}))
      module = module[0][module_name]
    module[1][type_node.itl_name] = type_node

  # Recursively Generate Python Packages
  create_package(args.package_name, args.output, args.package_name, modules)
