#!/usr/bin/env python3

# A Prototype for Generating a Python Mapping from an ITL File

import sys
import json
from enum import Enum, auto
from argparse import ArgumentParser
from pathlib import Path
from os.path import relpath

class Name:

  def __init__(self, itl_name=None, parts=None):
    if itl_name is not None and parts is None:
      self.itl_name = itl_name
      self.parts = itl_name.split(':')[1].split('/')
    elif itl_name is None and parts is not None:
      self.itl_name = None
      self.parts = parts
    else:
      raise ValueError('Either parts or itl_name must be passed')

class Type:

  def __init__(self, note):
    self.note = note
    self.name = None

  def set_name(self, itl_name=None, parts=None):
    self.name = Name(itl_name=itl_name, parts=parts)

  def local_name(self):
    if self.name:
      return self.name.parts[-1]
    return None

  def parent_name(self):
    if self.name:
      return self.name.parts[:-1]
    return None

  def accept(self, visitor):
    raise NotImplementedError

class Module(Type):

  def __init__(self, parent, name):
    super().__init__(None)
    self.parent = parent
    name_parts = []
    if parent and name:
      name_parts.extend(parent.name.parts)
      name_parts.append(name)
    self.set_name(parts=name_parts)
    self.submodules = {}
    self.types = {}

  def accept(self, visitor):
    for type_node in self.types.values():
      type_node.accept(visitor)

    for submodule in self.submodules.values():
      visitor.visit_module(submodule)

class PrimitiveType(Type):

  class Kind(Enum):
    u8 = auto()
    i8 = auto()
    u16 = auto()
    i16 = auto()
    u32 = auto()
    i32 = auto()
    u64 = auto()
    i64 = auto()
    f32 = auto()
    f64 = auto()
    c8 = auto()
    s8 = auto()

  def __init__(self, kind, note):
    super().__init__(note)
    if kind not in self.Kind:
      raise ValueError('Invalid Primitive Kind: ' + repr(kind))
    self.kind = kind

class StructType(Type):

  def __init__(self, note):
    super().__init__(note)
    self.fields = {}

  def add_field(self, name, type_node, optional):
    self.fields[name] = (type_node, optional)

  def accept(self, visitor):
    visitor.visit_struct(self)

class EnumType(Type):

  def __init__(self, note):
    super().__init__(note)
    self.members = {}
    self.default_member = None

  def add_member(self, name, value):
    self.members[name] = value
    if self.default_member is None:
      self.default_member = name

  def accept(self, visitor):
    visitor.visit_enum(self)

class TypeVisitor:

  def visit_module(self, module):
    module.accept(self)

  def visit_struct(self, struct_type):
    raise NotImplementedError

  def visit_enum(self, enum_type):
    raise NotImplementedError

class Output(TypeVisitor):

  def __init__(self, path : Path):
    self.path = path
    self.contents = []

  def write(self):
    self.path.write_text('\n'.join(self.contents))

  def extend(self, lines, insert_newline=True):
    if self.contents and insert_newline:
      self.contents.append('')
    self.contents.extend(lines)

class PythonOutput(Output):

  primitive_types = { # (Python Type, Default Default Value)
    PrimitiveType.Kind.u8: ('int', '0'),
    PrimitiveType.Kind.i8: ('int', '0'),
    PrimitiveType.Kind.u16: ('int', '0'),
    PrimitiveType.Kind.i16: ('int', '0'),
    PrimitiveType.Kind.u32: ('int', '0'),
    PrimitiveType.Kind.i32: ('int', '0'),
    PrimitiveType.Kind.u64: ('int', '0'),
    PrimitiveType.Kind.i64: ('int', '0'),
    PrimitiveType.Kind.f32: ('float', '0.0'),
    PrimitiveType.Kind.f64: ('float', '0.0'),
    PrimitiveType.Kind.c8: ('str', "'\\x00'"),
    PrimitiveType.Kind.s8: ('str', "''"),
  }

  def __init__(self, path):
    super().__init__(path)

  def write(self):
    self.path.write_text('\n'.join([
      'def _pyopendds_inject_idl(module_name):',
      '  from pyopendds.IDL import IDL',
      '  idl = IDL()',
      ] + self.contents + [
      '  idl.inject(module_name)',
      '_pyopendds_inject_idl(__name__)',
      'del _pyopendds_inject_idl', ''
      ]))

  def visit_module(self, module):
    if module.name.parts:
      self.extend(["  idl.add_module('{}', '{}')".format(
        '.'.join(module.parent_name()),
        module.local_name())
      ])
    super().visit_module(module)

  def visit_struct(self, struct_type):
    self.extend(["  idl.add_struct('{}', '{}', [".format(
        '.'.join(struct_type.parent_name()),
        struct_type.local_name())] +
      ["    ('{}'),".format(name) for name in struct_type.fields] +
    ["  ])"])

  def visit_enum(self, enum_type):
    self.extend(["  idl.add_enum('{}', '{}', [".format(
        '.'.join(enum_type.parent_name()),
        enum_type.local_name())] +
      ["    '{}',".format(name) for name in enum_type.members] +
    ["  ])"])

def parse_int(details):
  note = details.get('note', {})
  unsigned = 'unsigned' in details and details['unsigned'] == True
  enum = 'values' in details and 'constrained' in details and details['constrained']
  char = False
  try:
    char = details['note']['presentation']['type'] == 'char'
  except KeyError:
    pass

  kind = None
  if 'bits' in details:
    bits = details['bits']
    if bits == 8:
      if unsigned:
        kind = PrimitiveType.Kind.u8
      else:
        kind = PrimitiveType.Kind.i8
    elif bits == 16:
      if unsigned:
        kind = PrimitiveType.Kind.u16
      else:
        kind = PrimitiveType.Kind.i16
    elif bits == 32:
      if unsigned:
        kind = PrimitiveType.Kind.u32
      else:
        kind = PrimitiveType.Kind.i32
    elif bits == 64:
      if unsigned:
        kind = PrimitiveType.Kind.u64
      else:
        kind = PrimitiveType.Kind.i64

  if char and kind == PrimitiveType.Kind.u8:
    kind = PrimitiveType.Kind.c8
  elif enum:
    enum_type = EnumType(note)
    for k, v in details['values'].items():
      enum_type.add_member(k, v)
    return enum_type

  if kind:
    return PrimitiveType(kind, note)
  else:
    raise ValueError('Can\'t decide what this int type is: ' + repr(details))

def parse_float(details):
  raise NotImplementedError

def parse_fixed(details):
  raise NotImplementedError

def parse_string(details):
  return PrimitiveType(PrimitiveType.Kind.s8, details.get('note', {}))

def parse_sequence(types, details):
  raise NotImplementedError

def parse_record(types, details):
  struct_type = StructType(details.get('note', {}))
  for field_dict in details['fields']:
    struct_type.add_field(
      field_dict['name'], parse_type(types, field_dict['type']),
      field_dict.get('optional', False))
  return struct_type

def parse_union(types, details):
  raise NotImplementedError

def parse_alias(types, details):
  the_type = parse_type(types, details['type'])
  the_type.set_name(details['name'])
  return the_type

def parse_typedef(types, details):
  kind = details['kind']
  if kind == 'int':
    return parse_int(details)
  elif kind == 'float':
    return parse_float(details)
  elif kind == 'fixed':
    return parse_fixed(details)
  elif kind == 'string':
    return parse_string(details)
  elif kind == 'sequence':
    return parse_sequence(types, details)
  elif kind == 'record':
    return parse_record(types, details)
  elif kind == 'union':
    return parse_union(types, details)
  elif kind == 'alias':
    return parse_alias(types, details)
  else:
    raise ValueError(
      'Kind "{}" is not a valid type for parse_typedef()'.format(kind))

def parse_type(types, details):
  details_type = type(details)
  if details_type is str:
    if details in types:
      return types[details]
    else:
      raise ValueError("Invalid Type: " + details)
  elif details_type is dict:
    return parse_typedef(types, details)
  else:
    raise TypeError(
      'Type {} is not a valid type for parse_type()'.format(details_type.__name__))

def parse_root(types, itl):
  for itl_type in itl['types']:
    parsed_type = parse_type(types, itl_type)
    # opendds_idl produces ITL that includes types from included IDL files, so
    # just use the first definition we found.
    if parsed_type.name.itl_name not in types:
      types[parsed_type.name.itl_name] = parsed_type

if __name__ == "__main__":
  # Parse Arguments
  argparser = ArgumentParser(description='ITL to Python Mapping')
  argparser.add_argument('itl_files', metavar='ITL_FILE', type=Path, nargs='+')
  argparser.add_argument('-n', '--package-name', type=str)
  argparser.add_argument('-o', '--output', type=Path, default=Path('.'))
  args = argparser.parse_args()

  if args.package_name is None:
    if len(args.itl_files) > 1:
      sys.exit('--package-name is required when using multiple ITL files')
    args.package_name = args.itl_files[0].stem

  # Parse ITL Files for Types
  types = {}
  for itl_file in args.itl_files:
    with itl_file.open() as f:
      parse_root(types, json.load(f))

  # Sort Types into Modules
  root_module = Module(None, '')
  for type_node in types.values():
    module = root_module
    for module_name in type_node.parent_name():
      if module_name not in module.submodules:
        module.submodules[module_name] = Module(module, module_name)
      module = module.submodules[module_name]
    module.types[type_node.name.itl_name] = type_node

  path = args.output / args.package_name
  path.mkdir(exist_ok=True)
  pyout = PythonOutput(path / '__init__.py')
  pyout.visit_module(root_module)
  pyout.write()
