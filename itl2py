#!/usr/bin/env python3

# A Prototype for Generating a Python Mapping from an ITL File

import sys
import json
from enum import Enum, auto
from argparse import ArgumentParser
from pathlib import Path
from typing import List

from pyopendds_dev.itl2py import *

itl_ext = '.itl'

class Name:

  def __init__(self, itl_name=None, parts=None):
    if itl_name is not None and parts is None:
      self.itl_name = itl_name
      self.parts = itl_name.split(':')[1].split('/')
    elif itl_name is None and parts is not None:
      self.itl_name = 'IDL:{}:1.0'.format('/'.join(parts))
      self.parts = parts
    else:
      raise ValueError('Either parts or itl_name must be passed')

  def join(self,sep = '.'):
    return sep.join(self.parts)

class Node:

  def __init__(self, note):
    self.note = note
    self.name = None
    self.is_topic_type = False

  def set_name(self, itl_name=None, parts=None):
    self.name = Name(itl_name=itl_name, parts=parts)

  def local_name(self):
    if self.name:
      return self.name.parts[-1]
    return None

  def parent_name(self):
    if self.name:
      return Name(parts=self.name.parts[:-1])
    return None

  def accept(self, visitor):
    raise NotImplementedError

class Module(Node):

  def __init__(self, parent, name):
    super().__init__(None)
    self.parent = parent
    name_parts = []
    if parent and name:
      name_parts.extend(parent.name.parts)
      name_parts.append(name)
    self.set_name(parts=name_parts)
    self.submodules = {}
    self.types = {}

  def accept(self, visitor):
    for type_node in self.types.values():
      type_node.accept(visitor)

    for submodule in self.submodules.values():
      visitor.visit_module(submodule)

class PrimitiveType(Node):

  class Kind(Enum):
    u8 = auto()
    i8 = auto()
    u16 = auto()
    i16 = auto()
    u32 = auto()
    i32 = auto()
    u64 = auto()
    i64 = auto()
    f32 = auto()
    f64 = auto()
    c8 = auto()
    s8 = auto()

  def __init__(self, kind, note):
    super().__init__(note)
    if kind not in self.Kind:
      raise ValueError('Invalid Primitive Kind: ' + repr(kind))
    self.kind = kind

  def is_int(self):
    return {
      self.Kind.u8: True,
      self.Kind.i8: True,
      self.Kind.u16: True,
      self.Kind.i16: True,
      self.Kind.u32: True,
      self.Kind.i32: True,
      self.Kind.u64: True,
      self.Kind.i64: True,
      self.Kind.f32: False,
      self.Kind.f64: False,
      self.Kind.c8: False,
      self.Kind.s8: False,
    }[self.kind]

  def is_string(self):
    return {
      self.Kind.u8: False,
      self.Kind.i8: False,
      self.Kind.u16: False,
      self.Kind.i16: False,
      self.Kind.u32: False,
      self.Kind.i32: False,
      self.Kind.u64: False,
      self.Kind.i64: False,
      self.Kind.f32: False,
      self.Kind.f64: False,
      self.Kind.c8: False,
      self.Kind.s8: True,
    }[self.kind]

class StructType(Node):

  def __init__(self, note):
    super().__init__(note)
    self.fields = {}

  def add_field(self, name, type_node, optional):
    self.fields[name] = (type_node, optional)

  def accept(self, visitor):
    visitor.visit_struct(self)

class EnumType(Node):

  def __init__(self, note):
    super().__init__(note)
    self.members = {}
    self.default_member = None

  def add_member(self, name, value):
    self.members[name] = value
    if self.default_member is None:
      self.default_member = name

  def accept(self, visitor):
    visitor.visit_enum(self)

class NodeVisitor:

  def visit_module(self, module):
    module.accept(self)

  def visit_struct(self, struct_type):
    raise NotImplementedError

  def visit_enum(self, enum_type):
    raise NotImplementedError

class Output(NodeVisitor):

  def __init__(self, path):
    self.path = Path(path)
    self.contents = []

  def before(self):
    return ''

  def after(self):
    return ''

  def write(self):
    self.path.write_text(self.before() + ''.join(self.contents) + self.after())

  def append(self, what):
    self.contents.append(what + '\n')

class PythonOutput(Output):

  primitive_types = { # (Python Type, Default Default Value)
    PrimitiveType.Kind.u8: ('int', '0'),
    PrimitiveType.Kind.i8: ('int', '0'),
    PrimitiveType.Kind.u16: ('int', '0'),
    PrimitiveType.Kind.i16: ('int', '0'),
    PrimitiveType.Kind.u32: ('int', '0'),
    PrimitiveType.Kind.i32: ('int', '0'),
    PrimitiveType.Kind.u64: ('int', '0'),
    PrimitiveType.Kind.i64: ('int', '0'),
    PrimitiveType.Kind.f32: ('float', '0.0'),
    PrimitiveType.Kind.f64: ('float', '0.0'),
    PrimitiveType.Kind.c8: ('str', "'\\x00'"),
    PrimitiveType.Kind.s8: ('str', "''"),
  }

  def __init__(self,
      output_path: Path,
      python_package_name: str,
      native_package_name: str):
    self.python_package_name = python_package_name
    self.native_package_name = native_package_name
    path = output_path / python_package_name
    path.mkdir(parents=True, exist_ok=True)
    super().__init__(path / '__init__.py')
    self.append('''\
def _pyopendds_inject_idl(module_name):
    from pyopendds.IDL import IDL
    idl = IDL()
''')

  def write(self):
    self.append('''
    idl.inject(module_name)
_pyopendds_inject_idl(__name__)
del _pyopendds_inject_idl''')
    super().write()

  def visit_module(self, module):
    if module.name.parts:
      self.append("    idl.add_module('{}', '{}')".format(
        module.parent_name().join(),
        module.local_name())
      )
    super().visit_module(module)

  def visit_struct(self, struct_type):
    self.append("    idl.add_struct('{}', '{}', '{}', [".format(
      struct_type.parent_name().join(),
      struct_type.local_name(),
      self.native_package_name if struct_type.is_topic_type else None))
    for name in struct_type.fields:
      self.append("        ('{}'),".format(name))
    self.append("    ])")

  def visit_enum(self, enum_type):
    self.append("    idl.add_enum('{}', '{}', [".format(
      enum_type.parent_name().join(),
      enum_type.local_name()))
    for name in enum_type.members:
      self.append("        '{}',".format(name))
    self.append("    ])")

class CppOutput(Output):

  def __init__(self, output_path: Path,
      python_package_name: str,
      native_package_name: str,
      idl_names: List[str]):
    self.python_package_name = python_package_name
    self.native_package_name = native_package_name
    super().__init__(output_path / (native_package_name + '.cpp'))

    self.topic_types = []

    for name in idl_names:
      self.append('#include <' + name + 'TypeSupportImpl.h>')
    self.append('''
#include <dds/DdsDcpsDomainC.h>

#include <Python.h>

#include <stdexcept>

namespace PyOpenDDS {

/// Get Contents of Capsule from a PyObject
template <typename T>
T* get_capsule(PyObject* obj)
{
  T* rv = 0;
  PyObject* capsule = PyObject_GetAttrString(obj, "_var");
  if (capsule && PyCapsule_CheckExact(capsule)) {
    rv = static_cast<T*>(PyCapsule_GetPointer(capsule, NULL));
  }
  return rv;
}

class Exception : public std::exception {
public:
  Exception(const char* message)
  : message_(message)
  {
  }

  virtual const char* what() const noexcept
  {
    return message_;
  }

private:
  const char* message_;
};

template<typename T>
class TypeBase {
public:
  typedef typename OpenDDS::DCPS::DDSTraits<T> Traits;
  typedef typename Traits::TypeSupportType TypeSupport;
  typedef typename Traits::TypeSupportTypeImpl TypeSupportImpl;

  /**
   * Callback for Python to call when the TypeSupport capsule is deleted
   */
  static void delete_typesupport(PyObject* capsule)
  {
    if (PyCapsule_CheckExact(capsule)) {
      delete static_cast<TypeSupportImpl*>(
        PyCapsule_GetPointer(capsule, NULL));
    }
  }

  static void register_type(PyObject* pyparticipant)
  {
    // Get DomainParticipant_var
    DDS::DomainParticipant* participant =
      get_capsule<DDS::DomainParticipant>(pyparticipant);
    if (!participant) {
      throw Exception("Could not get native particpant");
    }

    // Register with OpenDDS
    TypeSupportImpl* type_support = new TypeSupportImpl;
    if (type_support->register_type(participant, "") != DDS::RETCODE_OK) {
      delete type_support;
      type_support = 0;
      throw Exception("Could not create register type");
    }

    // Store TypeSupport in Python Participant
    PyObject* capsule = PyCapsule_New(participant, NULL, delete_typesupport);
    if (!capsule) {
      throw Exception("Could not create ts capsule");
    }
    PyObject* list = PyObject_GetAttrString(
      pyparticipant, "_registered_typesupport");
    if (!list || !PyList_Check(list)) {
      throw Exception("Could not get ts list");
    }
    if (PyList_Append(list, capsule)) {
      PyErr_Print();
      throw Exception("Could not append ts to list");
    }
  }
};
template<typename T> class Type;

long get_python_long_attr(PyObject* py, const char* attr_name)
{
  PyObject* attr = PyObject_GetAttrString(py, attr_name);
  if (!attr) {
    PyErr_Print();
    throw Exception("python error occured");
  }
  if (!PyLong_Check(attr)) {
    throw Exception("python attribute isn't an int");
  }
  long long_value = PyLong_AsLong(attr);
  if (long_value == -1 && PyErr_Occurred()) {
    PyErr_Print();
    throw Exception("python error occured");
  }
  return long_value;
}
''')

  def visit_struct(self, struct_type):
    cpp_name = '::' + struct_type.name.join('::')
    if struct_type.is_topic_type:
      self.topic_types.append(cpp_name)
    self.append('''\
template<>
class Type<''' + cpp_name + '''> : public TypeBase<''' + cpp_name + '''> {
public:

  static PyObject* get_python_class()
  {
    PyObject* module = PyImport_ImportModule("''' + self.python_package_name + '''");
    if (!module) return 0;''')

    for name in struct_type.parent_name().parts:
      self.append('''\
    module = PyObject_GetAttrString(module, "''' + name + '''");
    if (!module) return 0;''')

    self.append('''\
    return PyObject_GetAttrString(module, "''' + struct_type.local_name() + '''");
  }

  static void to_python(const ''' + cpp_name + '''& cpp, PyObject*& py)
  {
    PyObject* cls = get_python_class();
    if (py) {
      if (PyObject_IsInstance(cls, py) != 1) {
        throw Exception("Python object is not a valid type");
      }
    } else {
      py = PyObject_CallObject(cls, nullptr);
      if (!py) {
        PyErr_Print();
        throw Exception("Could not call __init__ for new class");
      }
    }
''');

    for field_name, (field_type, _) in struct_type.fields.items():
      if isinstance(field_type, PrimitiveType) and field_type.is_int():
        self.append('''\
    if (PyObject_SetAttrString(py, "''' + field_name + '''", PyLong_FromLong(cpp.''' + field_name + '''))) {
      PyErr_Print();
      throw Exception("Type<''' + cpp_name + '''>::to_python: Could not set ''' + field_name + '''");
    }''')
      else:
        self.append('    // ' + field_name + ' was left unimplemented')

    self.append('''\
  }

  static ''' + cpp_name + ''' from_python(PyObject* py)
  {
    ''' + cpp_name + ''' rv;

    PyObject* cls = get_python_class();
    if (PyObject_IsInstance(py, cls) != 1) {
      throw Exception("Python object is not a valid type");
    }
''');

    for field_name, (field_type, _) in struct_type.fields.items():
      if isinstance(field_type, PrimitiveType) and field_type.is_int():
        self.append('''\
    rv.''' + field_name + ''' = get_python_long_attr(py, "''' + field_name + '''");''')
      else:
        self.append('    // ' + field_name + ' was left unimplemented')

    self.append('''
    return rv;
  }
};
''')

  def visit_enum(self, enum_type):
    pass

  def after(self):
    def for_each_topic_type(what):
      lines = ''
      first = True
      for topic_type in self.topic_types:
        if first:
          lines += '  '
          first = False
        else:
          lines += ' else '
        lines += '''\
if (pytype == PyOpenDDS::Type<''' + topic_type + '''>::get_python_class()) {
''' + what(topic_type) + '''\
  }'''
      return lines
    lines = '''\
} // PyOpenDDS\n

static PyObject* pyregister_type(PyObject* self, PyObject* args)
{
  // Get Arguments
  PyObject* pyparticipant;
  PyObject* pytype;
  if (!PyArg_ParseTuple(args, "OO", &pyparticipant, &pytype)) {
    PyErr_SetString(PyExc_TypeError, "Invalid Arguments");
    return NULL;
  }

''' + for_each_topic_type(lambda topic_type: '''\
    PyOpenDDS::Type<''' + topic_type + '''>::register_type(pyparticipant);
    Py_RETURN_NONE;
''') + '''

  PyErr_SetString(PyExc_Exception, "Could Not Match Python Type");
  return NULL;
}

static PyObject* pytype_name(PyObject* self, PyObject* args)
{
  // Get Arguments
  PyObject* pytype;
  if (!PyArg_ParseTuple(args, "O", &pytype)) {
    PyErr_SetString(PyExc_TypeError, "Invalid Arguments");
    return NULL;
  }

  const char* type_name = 0;

''' + for_each_topic_type(lambda topic_type: '''\
    type_name = PyOpenDDS::Type<''' + topic_type + '''>::Traits::type_name();
''') + '''

  if (type_name) {
    return PyUnicode_FromString(type_name);
  }

  PyErr_SetString(PyExc_Exception, "Could Not Get OpenDDS Type Name");
  return NULL;
}

static PyMethodDef ''' + self.native_package_name + '''_Methods[] = {
  {
    "register_type", pyregister_type, METH_VARARGS, ""
  },
  {
    "type_name", pytype_name, METH_VARARGS, ""
  },
  {NULL, NULL, 0, NULL}
};

static struct PyModuleDef ''' + self.native_package_name + '''_Module = {
  PyModuleDef_HEAD_INIT,
  "''' + self.native_package_name + '''", "",
  -1, // Global State Module, because OpenDDS uses Singletons
  ''' + self.native_package_name + '''_Methods
};

PyMODINIT_FUNC PyInit_''' + self.native_package_name + '''()
{
  return PyModule_Create(&''' + self.native_package_name + '''_Module);
}
'''
    return lines

def parse_int(details):
  note = details.get('note', {})
  unsigned = 'unsigned' in details and details['unsigned'] == True
  enum = 'values' in details and 'constrained' in details and details['constrained']
  char = False
  try:
    char = details['note']['presentation']['type'] == 'char'
  except KeyError:
    pass

  kind = None
  if 'bits' in details:
    bits = details['bits']
    if bits == 8:
      if unsigned:
        kind = PrimitiveType.Kind.u8
      else:
        kind = PrimitiveType.Kind.i8
    elif bits == 16:
      if unsigned:
        kind = PrimitiveType.Kind.u16
      else:
        kind = PrimitiveType.Kind.i16
    elif bits == 32:
      if unsigned:
        kind = PrimitiveType.Kind.u32
      else:
        kind = PrimitiveType.Kind.i32
    elif bits == 64:
      if unsigned:
        kind = PrimitiveType.Kind.u64
      else:
        kind = PrimitiveType.Kind.i64

  if char and kind == PrimitiveType.Kind.u8:
    kind = PrimitiveType.Kind.c8
  elif enum:
    enum_type = EnumType(note)
    for k, v in details['values'].items():
      enum_type.add_member(k, v)
    return enum_type

  if kind:
    return PrimitiveType(kind, note)
  else:
    raise ValueError('Can\'t decide what this int type is: ' + repr(details))

def parse_float(details):
  raise NotImplementedError

def parse_fixed(details):
  raise NotImplementedError

def parse_string(details):
  return PrimitiveType(PrimitiveType.Kind.s8, details.get('note', {}))

def parse_sequence(types, details):
  raise NotImplementedError

def parse_record(types, details):
  struct_type = StructType(details.get('note', {}))
  for field_dict in details['fields']:
    struct_type.add_field(
      field_dict['name'], parse_type(types, field_dict['type']),
      field_dict.get('optional', False))
  return struct_type

def parse_union(types, details):
  raise NotImplementedError

def parse_alias(types, details):
  the_type = parse_type(types, details['type'])
  the_type.set_name(details['name'])
  the_type.is_topic_type = details['note'].get("is_dcps_data_type", False) if 'note' in details else False
  return the_type

def parse_typedef(types, details):
  kind = details['kind']
  if kind == 'int':
    return parse_int(details)
  elif kind == 'float':
    return parse_float(details)
  elif kind == 'fixed':
    return parse_fixed(details)
  elif kind == 'string':
    return parse_string(details)
  elif kind == 'sequence':
    return parse_sequence(types, details)
  elif kind == 'record':
    return parse_record(types, details)
  elif kind == 'union':
    return parse_union(types, details)
  elif kind == 'alias':
    return parse_alias(types, details)
  else:
    raise ValueError(
      'Kind "{}" is not a valid type for parse_typedef()'.format(kind))

def parse_type(types, details):
  details_type = type(details)
  if details_type is str:
    if details in types:
      return types[details]
    else:
      raise ValueError("Invalid Type: " + details)
  elif details_type is dict:
    return parse_typedef(types, details)
  else:
    raise TypeError(
      'Type "{}" is not a valid type for parse_type()'.format(details_type.__name__))

def parse_itl(types, itl):
  for itl_type in itl['types']:
    parsed_type = parse_type(types, itl_type)
    # opendds_idl produces ITL that includes types from included IDL files, so
    # just use the first definition we found.
    if parsed_type.name.itl_name not in types:
      types[parsed_type.name.itl_name] = parsed_type

def get_ast(types):
  root_module = Module(None, '')
  for type_node in types.values():
    module = root_module
    for module_name in type_node.parent_name().parts:
      if module_name not in module.submodules:
        module.submodules[module_name] = Module(module, module_name)
      module = module.submodules[module_name]
    module.types[type_node.name.itl_name] = type_node
  return root_module

if __name__ == "__main__":
  # Parse Arguments
  argparser = ArgumentParser(description='ITL to Python Mapping')
  argparser.add_argument('itl_files', metavar='ITL_FILE', type=Path, nargs='+')
  argparser.add_argument('-n', '--package-name', type=str)
  argparser.add_argument('-o', '--output', type=Path, default=Path('.'))
  argparser.add_argument('--cmake-idl-name', type=str, default=None)
  args = argparser.parse_args()

  if args.package_name is None:
    if len(args.itl_files) > 1:
      sys.exit('--package-name is required when using multiple ITL files')
    args.package_name = 'py' + args.itl_files[0].stem
    if args.cmake_idl_name is None:
      args.cmake_idl_name = args.itl_files[0].stem + '_idl'

  # Parse ITL Files for Types
  types = {}
  idl_names = []
  for itl_file in args.itl_files:
    idl_names.append(itl_file.name[:-len(itl_ext)])
    with itl_file.open() as f:
      parse_itl(types, json.load(f))
  ast = get_ast(types)

  # TODO
  # # If the package only contains a single module of the same name, eliminate
  # # that module.
  # if len(ast.submodules) == 1:
  #   submodule = next(iter(ast.submodules.values()))
  #   if submodule.local_name() == args.package_name:
  #     submodule.parent = None
  #     submodule.set_name(parts=[])
  #     ast = submodule

  python_package_name = args.package_name
  native_package_name = '_' + args.package_name

  pyout = PythonOutput(args.output, python_package_name, native_package_name)
  pyout.visit_module(ast)
  pyout.write()

  cppout = CppOutput(args.output, python_package_name, native_package_name, idl_names)
  cppout.visit_module(ast)
  cppout.write()

  write_setup_py(args.output, python_package_name, native_package_name)
  write_cmakelists_txt(args.output, native_package_name, args.cmake_idl_name)
