#!/usr/bin/env python3

# A Prototype for Generating a Python Mapping from an ITL File

import sys
from argparse import ArgumentParser
from pathlib import Path
import json

from pyopendds.dev.itl2py import *

if __name__ == "__main__":
  # Parse Arguments
  argparser = ArgumentParser(description='ITL to Python Mapping')
  argparser.add_argument('itl_files', metavar='ITL_FILE', type=Path, nargs='+')
  argparser.add_argument('-n', '--package-name', type=str)
  argparser.add_argument('-o', '--output', type=Path, default=Path('.'))
  argparser.add_argument('--cmake-idl-name', type=str, default=None)
  args = argparser.parse_args()

  if args.package_name is None:
    if len(args.itl_files) > 1:
      sys.exit('--package-name is required when using multiple ITL files')
    args.package_name = 'py' + args.itl_files[0].stem
    if args.cmake_idl_name is None:
      args.cmake_idl_name = args.itl_files[0].stem + '_idl'

  # Parse ITL Files for Types
  types = {}
  idl_names = []
  for itl_file in args.itl_files:
    idl_names.append(itl_file.name[:-len('.itl')])
    with itl_file.open() as f:
      parse_itl(types, json.load(f))
  ast = get_ast(types)

  # TODO
  # # If the package only contains a single module of the same name, eliminate
  # # that module.
  # if len(ast.submodules) == 1:
  #   submodule = next(iter(ast.submodules.values()))
  #   if submodule.local_name() == args.package_name:
  #     submodule.parent = None
  #     submodule.set_name(parts=[])
  #     ast = submodule

  python_package_name = args.package_name
  native_package_name = '_' + args.package_name

  pyout = PythonOutput(args.output, python_package_name, native_package_name)
  pyout.visit_module(ast)
  pyout.write()

  cppout = CppOutput(args.output, python_package_name, native_package_name, idl_names)
  cppout.visit_module(ast)
  cppout.write()

  write_setup_py(args.output, python_package_name, native_package_name)
  write_cmakelists_txt(args.output, native_package_name, args.cmake_idl_name)
